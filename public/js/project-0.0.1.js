// Generated by CoffeeScript 2.4.1
(function() {
  var Board, Cell, Scoreboard;

  Board = (function() {
    var COLORS;

    class Board {

      //constructor : (@scoreboard, @w = 6, @h = 6, @newCirclesNum = 3, @lineLength = 4) ->
      constructor(scoreboard1, w = 9, h = 9, newCirclesNum = 3, lineLength = 5) {
        var addCell, cell, i, j, l, m, ref, ref1, rowElement;
        this.scoreboard = scoreboard1;
        this.w = w;
        this.h = h;
        this.newCirclesNum = newCirclesNum;
        this.lineLength = lineLength;
        addCell = function(rowElement, cell) {
          var cellElement;
          cellElement = cell.getElement();
          cellElement.addEventListener("click", (event) => {
            return this.selectCell(cell);
          });
          rowElement.appendChild(cellElement);
          this.cells[i].push(cell);
          return this.emptyCells.push(cell);
        };
        this.enabled = true;
        // Two-dimensional array of cells.
        this.cells = [];
        this.emptyCells = [];
        this.element = document.createElement("tbody");
        for (i = l = 0, ref = this.h - 1; (0 <= ref ? l <= ref : l >= ref); i = 0 <= ref ? ++l : --l) {
          this.cells.push([]);
          rowElement = document.createElement("tr");
          this.element.appendChild(rowElement);
          for (j = m = 0, ref1 = this.w - 1; (0 <= ref1 ? m <= ref1 : m >= ref1); j = 0 <= ref1 ? ++m : --m) {
            cell = new Cell(this, i, j);
            addCell.call(this, rowElement, cell);
          }
        }
        this.addNewCircles();
      }

      // Reference to the DOM element.
      getElement() {
        return this.element;
      }

      addNewCircles() {
        var i, randomCell, randomCellIndex, randomColor, randomColorIndex;
        i = 0;
        // Add the predefined number of new circles.
        while (i++ < this.newCirclesNum) {
          // Get a random empty cell.
          randomCellIndex = Math.floor(Math.random() * this.emptyCells.length);
          randomCell = this.emptyCells[randomCellIndex];
          // Remove the cell from the empty cells array as we put the circle into it.
          this.emptyCells.splice(randomCellIndex, 1);
          // Get a random color for the new circle.
          randomColorIndex = Math.floor(Math.random() * COLORS.length);
          randomColor = COLORS[randomColorIndex];
          // Put the circle into the cell.
          randomCell.show(randomColor, true);
          console.log('Nova bola =',randomCellIndex,randomColor)
        }
        return this.removeLines();
      }

      removeLines() {
        var cell, i, j, k, l, len, m, n, ref, ref1, ref2;
        this.cellsToClean = [];
        for (i = l = 0, ref = this.h - 1; (0 <= ref ? l <= ref : l >= ref); i = 0 <= ref ? ++l : --l) {
          for (j = m = 0, ref1 = this.w - 1; (0 <= ref1 ? m <= ref1 : m >= ref1); j = 0 <= ref1 ? ++m : --m) {
            // Check for vertical lines.
            if (i < this.h - this.lineLength + 1) {
              this.testLine((function() {
                var n, ref2, results;
                results = [];
                for (k = n = 0, ref2 = this.lineLength - 1; (0 <= ref2 ? n <= ref2 : n >= ref2); k = 0 <= ref2 ? ++n : --n) {
                  results.push(this.cells[i + k][j]);
                }
                return results;
              }).call(this));
            }
            // Check for horizontal lines.
            if (j < this.w - this.lineLength + 1) {
              this.testLine((function() {
                var n, ref2, results;
                results = [];
                for (k = n = 0, ref2 = this.lineLength - 1; (0 <= ref2 ? n <= ref2 : n >= ref2); k = 0 <= ref2 ? ++n : --n) {
                  results.push(this.cells[i][j + k]);
                }
                return results;
              }).call(this));
            }
            // Check for lt > rb diagonal lines.
            if (i < this.h - this.lineLength + 1 && j < this.w - this.lineLength + 1) {
              this.testLine((function() {
                var n, ref2, results;
                results = [];
                for (k = n = 0, ref2 = this.lineLength - 1; (0 <= ref2 ? n <= ref2 : n >= ref2); k = 0 <= ref2 ? ++n : --n) {
                  results.push(this.cells[i + k][j + k]);
                }
                return results;
              }).call(this));
            }
            // Check for rt > lb diagonal lines.
            if (i < this.h - this.lineLength + 1 && j >= this.lineLength - 1) {
              this.testLine((function() {
                var n, ref2, results;
                results = [];
                for (k = n = 0, ref2 = this.lineLength - 1; (0 <= ref2 ? n <= ref2 : n >= ref2); k = 0 <= ref2 ? ++n : --n) {
                  results.push(this.cells[i + k][j - k]);
                }
                return results;
              }).call(this));
            }
          }
        }
        ref2 = this.cellsToClean;
        for (n = 0, len = ref2.length; n < len; n++) {
          cell = ref2[n];
          this.cleanCell(cell);
        }
        return this.scoreboard.increaseScore(this.cellsToClean.length);
      }

      testLine(line) {
        var cell, removeLine;
        removeLine = line.every(function(cell, index) {
          return index === line.length - 1 || cell.color && cell.color === line[index + 1].color;
        });
        if (removeLine) {
          return this.cellsToClean = this.cellsToClean.concat((function() {
            var l, len, results;
            results = [];
            for (l = 0, len = line.length; l < len; l++) {
              cell = line[l];
              if (this.cellsToClean.indexOf(cell) === -1) {
                results.push(cell);
              }
            }
            return results;
          }).call(this));
        }
      }

      cleanCell(cell) {
        cell.hide(true);
        return this.emptyCells.push(cell);
      }

      selectCell(cell) {
        var path;
        // If some circle is already selected and the user clicks on an empty cell,
        // move the selected circle to the clicked cell. 
        if (this.enabled && this.selectedCell && !cell.color) {
          path = this.findPath(this.selectedCell.column, this.selectedCell.row, cell.column, cell.row);
          if (path.length > 0) {
            this.moveCell(this.selectedCell, path);
            this.selectedCell = null;
          }
        }
        // If there is a circle in the clicked cell, select it.
        if (cell.color) {
          if (this.selectedCell) {
            this.selectedCell.deselect();
          }
          this.selectedCell = cell;
          return this.selectedCell.select();
        }
      }

      moveCell(movableCell, path1) {
        this.movableCell = movableCell;
        this.path = path1;
        // Disable parallel move invocation.
        this.enabled = false;
        // Reset the step counter.
        this.step = 0;
        // Add the clicked cell to the empty cells array as the circle is moving out of it.
        this.emptyCells.push(this.movableCell);
        // Initialize step by step move.
        return this.moveInterval = setInterval(() => {
          return this.makeNextCellMove();
        }, 100);
      }

      makeNextCellMove() {
        var cellIndex, movableCellColor, stepData;
        movableCellColor = this.movableCell.color;
        this.movableCell.hide();
        stepData = this.path[this.step];
        this.movableCell = this.cells[stepData.row][stepData.column];
        this.movableCell.show(movableCellColor);
        this.step++;
        if (this.step === this.path.length) {
          clearInterval(this.moveInterval);
          cellIndex = this.emptyCells.indexOf(this.movableCell);
          this.emptyCells.splice(cellIndex, 1);
          this.removeLines();
          if (this.cellsToClean.length === 0 || this.emptyCells.length === this.w * this.h) {
            // Add new circles if no cells are removed or there are no circles on the board.
            this.addNewCircles();
          }
          // Enable move invocation again upon move complete.
          return this.enabled = true;
        }
      }

      getQueueHashKey(column, row) {
        return `${column}.${row}`;
      }

      findPath(column1, row1, column2, row2) {
        this.targetColumn = column1;
        this.targetRow = row1;
        this.queue = [];
        this.queueHash = {};
        this.stepsToTarget = Number.MAX_VALUE;
        // Recursively navigate through the board to find the shortest path.
        this.inspectCell(column2, row2);
        // Return reversed path.
        return this.queue.reverse();
      }

      inspectCell(currentColumn, currentRow, queue = [], step = 0) {
        var cell, queueHashKey, stepData;
        // Target cell reached.
        if (currentColumn === this.targetColumn && currentRow === this.targetRow) {
          this.stepsToTarget = step;
          this.queue = queue;
        }
        // Column out of range.
        if (!((this.w > currentColumn && currentColumn >= 0))) {
          return;
        }
        // Row out of range.
        if (!((this.h > currentRow && currentRow >= 0))) {
          return;
        }
        // Get queue hash key of the inspected cell.
        queueHashKey = this.getQueueHashKey(currentColumn, currentRow);
        // Check if the cell has been already visited and that step value is less or equal to the current step value.
        if (this.queueHash[queueHashKey] <= step) {
          return;
        }
        // Get reference to the inspected cell.
        cell = this.cells[currentRow][currentColumn];
        // Ball in the cell.
        if (cell.color) {
          return;
        }
        // Add step to the queue.
        stepData = {
          column: currentColumn,
          row: currentRow,
          step: step
        };
        queue = queue.concat(stepData);
        this.queueHash[queueHashKey] = step;
        // Inspect adjacent cells.
        if (step < this.stepsToTarget) {
          step++;
          this.inspectCell(currentColumn - 1, currentRow, queue, step);
          this.inspectCell(currentColumn + 1, currentRow, queue, step);
          this.inspectCell(currentColumn, currentRow - 1, queue, step);
          return this.inspectCell(currentColumn, currentRow + 1, queue, step);
        }
      }

    };

    COLORS = ["circle-red", "circle-green", "circle-blue", "circle-yellow", "circle-orange"];

    return Board;

  }).call(this);

  Cell = class Cell {
    constructor(board1, row3, column3) {
      this.board = board1;
      this.row = row3;
      this.column = column3;
      this.element = document.createElement("td");
      this.image = document.createElement("div");
      this.element.appendChild(this.image);
    }

    // Reference to the DOM element.
    getElement() {
      return this.element;
    }

    show(color, animate = false) {
      var onAnimationEnd;
      this.color = color;
      this.image.className += " " + this.color;
      onAnimationEnd = (e) => {
        this.image.className = this.image.className.replace(/\bcircle-fade-in\b/, "");
        return this.image.removeEventListener(e.type, onAnimationEnd);
      };
      if (animate) {
        this.image.addEventListener("webkitAnimationEnd", onAnimationEnd);
        this.image.addEventListener("animationend", onAnimationEnd);
        return this.image.className += " circle-fade-in";
      }
    }

    hide(animate = false) {
      var onAnimationEnd;
      onAnimationEnd = (e) => {
        if (e) {
          this.image.removeEventListener(e.type, onAnimationEnd);
        }
        this.image.className = "";
        return this.color = null;
      };
      if (animate) {
        this.image.addEventListener("webkitAnimationEnd", onAnimationEnd);
        this.image.addEventListener("animationend", onAnimationEnd);
        return this.image.className += " circle-fade-out";
      } else {
        return onAnimationEnd();
      }
    }

    select() {
      return this.image.className += " circle-jump";
    }

    deselect() {
      return this.image.className = this.image.className.replace(/\bcircle-jump\b/, "");
    }

  };

  window.onload = function() {
    var board, scoreboard;
    scoreboard = new Scoreboard;
    document.getElementById("scoreboard").appendChild(scoreboard.getElement());
    board = new Board(scoreboard);
    return document.getElementById("board").appendChild(board.getElement());
  };

  Scoreboard = class Scoreboard {
    constructor() {
      this.element = document.createElement("p");
      this.resetScore();
    }

    // Reference to the DOM element.
    getElement() {
      return this.element;
    }

    resetScore() {
      this.score = 0;
      return this.updateScore();
    }

    increaseScore(numCircles) {
      if (numCircles >= 4) {
        this.score += 10 + (numCircles - 4) * 20;
      }
      return this.updateScore();
    }

    updateScore() {
      if (this.element.firstChild) {
        this.element.removeChild(this.element.firstChild);
      }
      return this.element.appendChild(document.createTextNode(this.score.toString()));
    }

  };

}).call(this);
